---
layout: osdoc
title: Formation AMU
group: General
permalink: /aix2014/
menuclass: external
ext_url: /aix2014
show: True
authors: Lotje van der Linden
---

## Vue d'ensemble

Cette formation sera composé en trois parties. D'abord, il y aura une brève présentation sur la constructions des expériences en géneral. Ensuite, nous allons créer une expérience simple mais réaliste. Pour finir, on va affiner notre expérience en utilisant quelques astuces des programmeurs avancées.

%--
toc:
 mindepth: 2
 maxdepth: 3
 exclude: ["Vue d'ensemble"]
--%	

## Introduction

Les diapositives de cette formation peut être téléchargé ici [TODO:link!]

### La question de recherche

Nous allons créer une expérience catégorique amorçage. Les participants voient brièvement une chaîne de lettres et doivent décider si la chaîne de lettres est un mot ou un non-mot (i.e., une tâche de décision lexicale). Pour indiquer sa décision, le participant doit appuyer sur une touche du clavier. Notre hypothèse est que la reconnaissance d'un mot sera plus vite quand la catégorie du mot est déjà amorcée. Pour amorcer la catégorie, on montrera un mot indiquant la catégorie (par ex. "ANIMAL") juste avant la présentation de la cible (ex. 'lapin'). On s'appelle ce mot amorçant un 'Prime'. Comme condition de contrôle, on présentera également des mots sans avoir amorcé leur catégorie. En tel cas, la cible est précédée par une chaîne de lettres non-informative (par ex. "XXXXX").

%--
figure:
 id: hypoth1
 source: hypoth1.png
 caption: |
  La reconnaissance d'un mot est plus vite si la catégorie du mot est amorcée par un Prime.
--%

### La séquence d'essai

Pour tester cette hypothèse, on va créer une expérience avec la séquence d'essai suivante: Chaque essai commencera avec un point de fixation (500 ms). Après, le Prime sera présenté brièvement (100 ms), suivi par un intervalle vide (1000 ms). Ensuite, la cible apparaît. La tâche du participant est d'indiquer aussi rapidement et précise que possible si la cible est un mot ou un non-mot. 

- Si la cible est un vrai mot: il faut appuyer la touche 'm'
- Si la cible est un non-mot: il faut appuyer la touche 'q'

A la fin de chaque essai, il faut enregistrer tous les variables nouvelles vers un fichier de sortie.

%--
figure:
 id: trialSeq1
 source: trialSeq1.png
 caption: |
  Example schématique de la séquence d'essai.
--%

### Hiérarchie de l'expérience

Pour commencer, on va construire une expérience très simple, qui contient seulement 2 bloc de 12 essais. La structure hiérarchique de notre expérience peut donc être représentée comme suit:
	
%--
figure:
 id: hierarchy
 source: hierarchy.png
 caption: |
  Réprésentation schématique de la structure hiérarchique.
--%

## Création d'une expérience simple

### Etape 1: Démarrer OpenSesame

Lorsque vous démarrez OpenSesame, vous recevrez un menu qui vous permet de choisir de:
	
- Ouvrir une expérience qui était récemment ouverte
- Ouvrir une autre expérience déjà existante
- Créer une nouvelle expérience ...
	- complètement vide ('Default template')
	- modèle étendu, qui est déjà partiellement programmé ('Extended template')

Pour gagner du temps, on va utiliser le modèle étendu. Double-cliquez sur l"Extended template" dans l'onglet "Get started!".

%--
figure:
 id: startup
 source: startup.png
 caption: |
  La fenêtre OpenSesame au démarrage.
--%

La vue d'ensemble montre la structure hiérarchique de l'"Extended template".

%--
figure:
 id: beforeDel
 source: beforeDel.png
 caption: |
 Extended template" comme on le voit dans la vue d'ensemble.
--%

Pour simplifier les choses, on commence par supprimer le 'practice_loop', qui réprésente un bloc d'entrainement. Pour exécuter cette suppression:

- Clic droit sur 'practice_loop' dans la vue d'ensemble
- Choisissez 'Supprimer'

%--
figure:
 id: delPract
 source: delPract.png
 caption: |
  Supprimer un élément (ici: 'practice_loop') de la structure hiérarchique.
--%

%--
figure:
 id: afterDel
 source: afterDel.png
 caption: |
  L'"Extended template" comme on le voit dans la vue d'ensemble après avoir supprimé le 'practice_loop'.
--%

Maintenant, la structure hiérarchique de la vue d'ensemble ressemble déjà beaucoup la structure schématique qui est représentée par %hierarchy. Cette ressemblance indique comment c'est utile de commencer par l'"Extended template".

### Etape 2: Definir les variables indépendantes

Pour commencer, nous nous limitons à deux variables indépendantes: "Cible" et "Prime". La variable "Cible" contient les mots d'une certaine catégorie qui le participant doit identifier. 
Par exemple:
	
- Des vrais mots: "chien", "chat", "lapin"
- Des non-mots: "chiun", "chot", "lapan"

La variable "Prime" contient le stimulus qu'on utilise pour amorcer la catégorie du mot:

- Pour les essais expérimentaux: "ANIMAL"
- Pour les essais de contrôle: "XXXXXX"

En total, ça donne 12 Cible*Prime combinaisons différentes. On s'appelle ces combinaisons *des conditions*. Ces 12 conditions constituent la liste d'essais dans 1 bloc (%hierarchy). Cette liste doit être remplit dans l'élément *block_loop*.  
Heureusement, on n'a pas besoin de taper toutes ces 12 combinaisons manuellement. Au lieu de cela, nous utilisons l'"Assistant de variables", qui va nous générer un *plan factoriel*. Sélectionnez l'élément 'block_loop' et cliquez sur le bouton "Assistant de variables".

%--
figure:
 id: blockloop
 source: blockloop.png
 caption: |
  Ouvrir l'élément *block_loop* et ouvrez l'Assistant de variables".
--%

Ensuite, tapez les noms de variables sur la première ligne de l'"Assistant de variables". Après, remplissez les deux colonnes en tapant chaque niveau du variable. Ensuite, cliquez "Ok".

%--
figure:
 id: wizard
 source: wizard.png
 caption: |
  Tapez le plan factoriel dans l'"Assistant de variables".
--%

Vous voyez que OpenSesame a générer notre entière liste d'essais.  

%--
figure:
 id: wizard
 source: wizard.png
 caption: |
  Tapez le plan factoriel dans l'Assistant de variables".
--%

Il est souvent pratique de dire OpenSesame quelle est la bonne réponse par essai en définissant la variable 'correct_response'. Ça permet OpenSesame de suivre les variables de la performance, comme:

- 'correct' (valeur 0 pour un réponse incorrect, valeur 1 pour un réponse correct)
- 'acc' (pourcentage correct)
- 'avg_rt' (temps de réaction moyen).

Pour dire OpenSesame quelle est la bonne réponse sur chaque essai:
	
- Cliquez sur le bouton "Ajouter une variable"
- Ecrivez "correct_response" et appuyez sur 'Enter'
- Maintenant, on a créé un colonne vide pour la nouvelle variable. Il faut donc le remplir. 
- Pour chaque ligne contenant un vrai mot, mettez 'm' comme bonne réponse. Pour chaque ligne contenant un non-mot, mettez 'q'.

%--
figure:
 id: wizard
 source: wizard.png
 caption: |
  Le *block_loop* après que vous avez ajouté la variable 'correct_response'.
--%

### Etape 3: Ajouter des éléments à la séquence d'essai

Comme illustré à la %trialSeq, l'objectif est de construire une séquence d'essai comme suit:
	
1. Présenter le point de fixation
2. Présenter le Prime
3. Présenter un écran vide (interval entre Prime et Cible)
4. Présenter la Cible
5. Collecter un réponse sur le clavier
6. Enregistrer tous les variables dans un fichier de sortie

On s'appelle ces 6 étapes différents *des événements*. On va réaliser ces 6 événements en ajoutant des *éléments* vers le *trial_sequence* de notre expérience.  

Pour les premiers 4 événements, on utilisera des éléments `sketchpad`. Cependant, pour l'instant, notre *trial_sequence* ne contient qu'un seul élément `sketchpad`. Il faut donc en ajouter encore 3.

Pour ajouter ces 3 éléments `sketchpad`:

- Regardez la barre d'outils à l'extrème gauche de l'écran OpenSesame
- Choisissez l'élément `sketchpad`
- Faites glisser l'élément vers la *trial_sequence* dans la vue d'ensemble.
- *Attention:* Pour faire apparaitre un élément *au dessous* d'un autre élément, déposer le *sur* cet autre élément.

%--
figure:
 id: dragdrop
 source: dragdrop.png
 caption: |
  Glisser-déposer des éléments (ici: des `sketchpad`s) de la barre d'outils vers la vue d'ensemble.
--%

Répétez la procédure glisser-déposer jusqu'à ce que vous avez 4 éléments `sketchad` dans votre *trial_sequence*. Par défaut, OpenSesame attribue des noms tels que "__sketchpad" aux éléments nouvellement crées. Ces noms ne sont pas très informative. Il est donc forcement recommandé de les changer. 

Pour réaliser ça:
	
- Clic droit sur un élément dans la vue d'ensemble
- Choisissez 'Renommer'
- Changez le nom

Appelez les éléments `sketchpad` *fixation*, *prime*, *interval* et *cible*, respectivement.

Après, la *trial_sequence* dans la vue d'ensemble ressemble à:

%--
figure:
 id: renamed
 source: renamed.png
 caption: |
  La *trial_sequence* après qu'on a ajouté et renommé trois nouveux éléments `sketchpad`.
--%

Les derniers deux événements de la séquence d'essai:
	
- collecter un réponse
- enregistrer les variables

sont déjà répresentés par les éléments `keyboard_response` et `logger`, respectivement.

### Etape 4: Créer les éléments *fixation*, *prime*, *interval* et *cible*

#### fixation

Maintenant, on va créer le content des éléments `sketchpad` grâce aux 'drawing tools' (des outils de dessin). On commence avec le `sketchpad` *fixation*.

- Ouvrez l'onglet *fixation* en cliquant sur cet élément dans la vue d'ensemble.
- Comme vous voyez, grâce à l'Extended template, le point de fixation est déjà dessiné. 

Cependant, il faut qu'on fasse un petit changement sur cet élément quand même. Actuellement, la durée de ce `sketchpad` est mis sur "keypress" (appui). Ça veut dire que le point de fixation sera présenté jusqu'a le sujet appuye sur un touche. Ce n'est pas ce qu'on veut. On veut que le point de fixation sera présenté par 500 ms (voyez %trialSeq), et que, aprés, l'expérience avance automatiquement.  
Pour réaliser ça, il faut changer la durée vers "500".

%--
figure:
 id: fixation
 source: fixation.png
 caption: |
  Le `sketchpad` 'fixation', avec une durée de 500 ms.
--%

#### prime

Pour le point de fixation, on a créé un `sketchpad` *invariable*. Un `sketchpad` invariable monte la même chose (ici: un point de fixation pendant 500 ms) sur chaque essai.  
On peut également créer des `sketchpad`s *variables*. Ça veut dire que le contient du `sketchpad` est défini par une variable indépendente. Grâce aux `sketchpad`s variables, on ne doit pas créer deux `sketchpad`s différents pour chaque niveau du variable Prime ("ANIMAL" et "XXXXX"). Au lieu de ça, on en crée qu'un, et on laisse décider OpenSesame quel Prime sera présenté sur chaque essai, au base de la liste *block_loop*.

Pour indiquer à OpenSesame qu'il s'agit d'un `sketchpad` variable, on utilise la méthode *entre-crochets*. La mêthode entre-crochets fonctionne comme suit:
	
- Ouvrez l'onglet *prime* en cliquant sur cet élément dans la vue d'ensemble
- Cliquer sur l'icone "Ab" pour sélectionner l'outil texte
- Cliquez sur le centre de l'écran
- Cela ouvrira une boite de dialogue vous demandant de spécifier un texte
- Au lieu de taper le prime (par ex. "ANIMAL") directement, on tape le nom du variable indépendente ('prime') entre crochets
- Les crochets indique que nous avons affaire à une texte variable.
- Donc, au lieu de présenter '[prime]' sur l'écran, OpenSesame présentera le valeur du variable (i.e. 'XXXXXX' ou 'ANIMAL') comme rétiré de la liste *block_loop*.
- Enfin, mettez la durée du *prime* sur 100 ms 

%--
figure:
 id: squarebrackets
 source: squarebrackets.png
 caption: |
  Réprésentation de la méthode 'entre crochets'. Les crochets indiquent que 'prime' doit être interprété comme un nom de variable, et que OpenSesame doit lire les valeurs de cette variable de la liste *block_loop*.
--%

#### interval

Le `sketchpad` *interval* est *invariable*. Il est facile de créer, parce qu'il s'agit de rien de plus qu'un écran vide avec une durée de 1000 ms.

#### cible

Le `sketchpad` *cible* est un sketchpad *variable*; comparable avec le sketchpad *prime*. Donc, on utilise encore une fois la méthode entre-crochets. La seule différence est que, cette fois, on met le nom de notre autre variable indépendente, 'cible', entre crochets.

Ensuite, on met la durée du `sketchpad` *cible* sur 0 ms. Ça peut vous semblez contre-intuitif, mais ça veut juste dire que OpenSesame va initialiser la prochaine élément (ici, *keyboard_response*) tout de suite. L'élément 'keyboard_item' lui même ne change pas ce qui est actuellement montrer au sujet sur l'écran. Donc, en somme, ça permet que le stimulus reste sur l'écran jusqu'à le sujet a appuyé sur une touche.

### Etape 5: La séquence de bloc

Jusqu'a maintenant, on a travaillé sur le niveau le plus bas dans notre structure hierarchique (%hierarchy); la séquence d'essai. Cependant, il faut également créer la séquence de bloc, et la séquence de la session entière.

Pour avoir une meilleure vue sur la bloc de séquence, on commence par cacher temporairement la séquence d'essai de la vue d'ensemble. Pour réaliser ça, cliquez le signe '-' dans la vue d'ensemble à gauche de l'élément *trial_sequence*.

%--
figure:
 id: blockSeq
 source: blockSeq.png
 caption: |
  La séquence de bloc.
--%

On voit mieux que, actuellement, la bloc de séquence se compose de trois éléments:
	
1. reset_feedback
2. block_loop
3. feedback

Cette séquence de bloc est déjà parfait pour notre expérience. 

- Avec l'élément *feedback*, on peut montrer au sujet, après chaque bloc, son pourcentage de réponses correctes, et son temps de réaction moyen. 
- L'élément *reset_feedback* assure que ces moyens sont réinitialisés après chaque bloc.
- Comme on a vu, l'élément *block_loop* fait 12 fois tourner la séquence d'essai (une fois pour chaque combinaison)

### Etape 6: La sequence de session

Le niveau le plus haut de notre structure hierarchique répresente la sequence de la session experimentale entière. Pour voir mieux cette séquence, on cache temporairement la séquence de bloc. 

%--
figure:
 id: sessSeq
 source: sessSeq.png
 caption: |
  La séquence de la session expérimentale entière.
--%

Maintenant, on voit clairement la séquence de la session experimentale entiere:

1. instructions
2. experimental_loop (qui fait tourner 1 séquence de bloc, qui, a sa tour, fait tourner 12 essais)
3. end_of_experiment

Même si cette séquence de session est déjà presque parfait, on va régler des petites choses dans chacun de ces éléments.

#### instructions

Le `sketchpad` *instructions* donne une explication de la tâche au sujet, qu'il peut lire avant de commencer la tâche. Maitenant, les instructions ne sont pas très suffissamment précises. 

Changez les comme suit:

- Cliquer sur l'icone "Ab" pour sélectionner l'outil texte
- Ecrit une petite texte qui informe le sujet qu'il faut appuyer:
	- 'm' si la cible est un vrai mot
	- 'q' si la cible est un non-mot

#### experimental_loop

Actuellement, notre expérience consiste juste d'un seul bloc expérimental. Chaque bloc, à son tour, est constitué d'un petit nombre d'essai (les 12 conditions sont montrés au sujet qu'une fois). Normalement, un tel nombre d'observations ne suffit pas pour faire des bonnes analyses statistiques. Pour augmenter le nombre de répétitions, on va changer le nombre de blocs expérimentaux comme suit:
	
- Ouvrez l'onglet *experimental_loop* en cliquant sur cet élément dans la vue d'ensemble
- Changer le nombre de répétitions dans la boite *Répéter*. Mettez-le vers '2'. Par conséquence, le bloc expérimental entier va être répété 2 fois.
	
#### end_of_experiment

Cet élément `sketchpad` informe le participant que l'expérience est terminé. Mettez ce message en français en utilisant l'outilt texte.

### Etape 7: Tester l'expérience

Félicitations!! Vous avez maintenant une expérience entièrement fonctionnel!
Donc, c'est le temps pour la tester. Pour executer le programme:
	
- Cliquer une des flêches vertes
- Entrez un numéro de sujet (par ex. '1')
- Une fênetre s'ouvre qui indique le nom de défaut du fichier de sortie. Si vous n'aimez pas ce nom, vous pouvez le changer
- Cliquez 'save'
- L'expérience sera lancé. Vous pouvez prétendre que vous avez un participant, pour vérifier si l'expérience fonctionne comme on le souhaite
- Si vous n'avez pas envie de dérouler l'expérience entiere (2 fois 12 essais) vous pouvez aborter l'expérience en appuyant la touche 'Esc' sur votre clavier. Ça interrompt immédiatement l'exécution de l'expérience, de sorte que vous pouvez continuer de la programmer.

Après d'avoir exécuté (un part de) votre expérience, vous pouvez voir si vos variables sont enrégistrées correctement dans le fichier de sortie. 

## Perfectionner l'expérience

### Etape 8: Donner du feedback après chaque essai

On va étendre la séquence d'essai avec un événement en plus: un élément `sketchpad` qui informe le participant après chaque réponse, si sa réponse était juste ou faux. En réalisant ça, on va apprendre deux astuces un peu plus avancés:
	
- Utiliser des *variables dépendantes* en ligne
- Utiliser des déclarations *exécuter-si* (run-if statements)

Pendant chaque essai, la précision du réponse du participant est enregistrée comme la variable 'correct':
	
- Si le participant répond correctement, la variable 'correct' obtient le valeur 1
- Si le participant répond mal, la variable 'correct' obtient le valeur 0

On va utiliser cette variable *en ligne*, pour déterminer si le participant doit être informé que sa réponse était juste (en lui montant un point de fixation vert) ou faux (en lui montant un point de fixation rouge). Pour réaliser ça:

- Ajoutez deux éléments `sketchpad` à la séquence d'essai. 
- Placez-les après l'élément *keyboard_response*. 
- Donnez-les des noms informatives, e.g. *juste* et *faux*.
- Mettez leurs durées vers 500 ms
- Ouvrez le sketchpad *juste* et dessinez un croix de fixation vert sur le centre du `sketchpad`. Pour effectuer cette opération:
	- Cliquez sur l'icone du point de fixation pour sélectionner cet outil. 
	- Changez son coleur du blanc vers vert, en tapant "green" dans la boite coulour. 
	- Cliquez sur le centre du sketchpad.
- Ouvrez le sketchpad 'feedback_incorrect' et répétez cette procédure. Assurez-vous que, pour l'*évaluation_incorrect*, le point de fixation le couleur soit rouge.

#### Utiliser des déclarations "Run-if" (exécuter-si)

- Cliquer sur l'élément 'trial_sequence' dans la vue d'ensemble'. Un onglet s'ouvre, qui donne une vue d'ensemble de chaque événément de la séquence. A droite, on voit les déclarations "Run if". Ils indiquent dans quelles circonstances OpenSesame exécutera chaque élément. Maintenant, ils sont tous éxécutés "always" ('toujours'). Ce valeur est correct pour tous nos éléments, sauf les éléments *juste* et *faux*'. Effectivement, à la fin de chaque essai, il faut seulement exécuter un de ces deux, en dépendant si le participant a répondu correctement ou incorrectement. 
- Pour programmer ça, il faut changer leurs déclarations "Run if" vers:
	- [correct] = 1
	- [correct] = 0
pour les éléments *juste* et *faux*, respectivement

Par conséquence, le sujet verra le point de fixation vert si sa réponse était juste, et le point de fixation rouge si sa réponse était faux.

### Etape 9: Varier un variable indépendante entre *blocs*

Imaginez que nous ne sommes pas seulement interessés sur l'effet du Prime, mais qu'on veut examiner si l'effet du Prime interagit avec l'effet de la durée de l'interval entre Prime et Cible. Par example, on peut élargir la question de recherche vers:
	
"La reconnaissance d'un mot, est-elle plus vite quand la categorie du mot est amorçée très récemment, mais non quand l'interval entre Prime et Cible augmente?"

%--
figure:
 id: hypoth2
 source: hypoth2.png
 caption: |
  Notre hypothèse est qu'il y aura un effet d'interaction.
--%

Pour répondre à cette question, il faut un deuxième variable indépendente: durée de l'interval. On va le donner deux valeurs différentes: 100 ms vs. 2000 ms.

Pour ajouter cette variable à notre expérience, on a deux possibilités:
	
- On peut ajouter une variable supplémentaire dans notre liste du 'block_loop'. Par conséquence, l'interval sera varié entre chaque essai
- On peut ajouter une variable dans notre liste du 'experimental_loop'. Par conséquence, l'interval sera varié seulement entre blocs (on aura un bloc entier avec interval 100, et un autre avec interval 2000.

Pour ce tutoriel, on choisit option 2. Pour réaliser cette opération:

- Ouvrez l'élément 'experimental_loop'
- Ajouter un variable 'interval'. Donnez-le ses 2 valeurs.



Comme derniere etappe, il faut qu'on change le sketchpad 'interval' d'un sketchpad invariable vers un sketchpad variable. Donc, on aura besoin de la méthode 'entre crochets'. Cette fois, on utilise cette méthode dans la boite 
																													
### Etape 10: Finished!

![](/img/fig/fig18.1.20.png)

__Fig 20.__ Finished!
{: .fig-caption}

Votre expérience est maintenant terminée. Cliquez sur le bouton "Exécuter" pour la tester.

## References

Math&ocirc;t, S., Schreij, D., & Theeuwes, J. (2012). OpenSesame: An open-source, graphical experiment builder for the social science. *Behavior Research Methods*, *44*(2), 313-324. doi:10.3758/s13428-011-0168-7
{: .reference}

[download]: /getting-opensesame/download/
[feedback]: /usage/feedback/
[forms]: /forms/about/
[forms-opensesame]: /forms/custom-forms/#opensesame-script
[forms-performance]: /forms/performance-issues-and-troubleshooting/
[forms-python]: /forms/custom-forms/#python
[slides]: /attachments/aps2013-workshop-slides.pdf
[variables]: /usage/variables-and-conditional-statements/#using-variables
[responses]: /usage/collecting-responses/
[tutorial]: /usage/step-by-step-tutorial/
[html-subset]: /usage/text-formatting/
[aps-page]: http://aps.psychologicalscience.org/convention/program_2013/search/viewProgram.cfm?Abstract_ID=26153
[smep]: http://www.smep.org/
[pdf]: /aps2013/index.pdf
[prepare-run]: /usage/prepare-run/#sketchpad-feedback
